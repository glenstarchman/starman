import sbt.complete.DefaultParsers._
import scala.util.Properties
import com.mojolly.scalate.ScalatePlugin.ScalateKeys._

addCompilerPlugin("tv.cntt" %% "xgettext" % "1.3")
addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0-M5" cross CrossVersion.full)
scalacOptions += "-P:xgettext:xitrum.I18n"
autoCompilerPlugins := true

val commonSettings = Seq(
  organization := "com.starman",
  //name := "starman",
  version := "1.0.1",
  scalaVersion := "2.11.7",
  crossScalaVersions := Seq("2.11.7"),
  resolvers += Resolver.sonatypeRepo("snapshots"),
  resolvers += Resolver.sonatypeRepo("releases"),
  resolvers += "jBCrypt Repository" at "http://repo1.maven.org/maven2/org/",
  resolvers += "RoundEights" at "http://maven.spikemark.net/roundeights",
  libraryDependencies ++= Seq(
    "commons-io" % "commons-io" % "2.4",
    "joda-time" % "joda-time" % "2.8.1",
    "org.json4s" %% "json4s-jackson" % "3.2.11"
  ),
  scalacOptions ++= Seq()
) //++ XitrumPackage.copy("config", "public", "scripts", "templates")


val baseBuildSettings = commonSettings ++ Seq(
	buildInfoKeys ++= Seq[BuildInfoKey](
    name, version, scalaVersion, sbtVersion,
    "hostname" -> java.net.InetAddress.getLocalHost().getHostName(),
    "deployer" -> System.getProperty("user.name"),
    "buildTimestamp" -> new java.util.Date(System.currentTimeMillis()),
    "gitHash" -> new java.lang.Object(){
      override def toString(): String = {
        try {
          val extracted = new java.io.InputStreamReader(
            java.lang.Runtime.getRuntime().exec("git rev-parse HEAD").getInputStream())
           (new java.io.BufferedReader(extracted)).readLine() match {
             case null => ""
             case x: String => x
           }
        } catch {
          case t: Throwable => "get git hash failed"
        }
      }
    }.toString()
  ),
	buildInfoPackage := "starman.common",
	buildInfoOptions += BuildInfoOption.BuildTime,
  buildInfoOptions += BuildInfoOption.ToMap,
  unmanagedClasspath in Compile <+= (baseDirectory) map { bd => Attributed.blank(bd / "config") },
  unmanagedClasspath in Runtime <+= (baseDirectory) map { bd => Attributed.blank(bd / "config") }
)

val templateSettings = Seq(
  scalateOverwrite := true,
  scalateTemplateConfig in Compile <<= (baseDirectory) { base =>
    Seq(
      TemplateConfig(
        base / "templates",
        Nil,
        Nil,
        Option("")
      )
    )
  }
)

val generateVersionFileTask = TaskKey[Unit]("generateVersion", "Generate src/xitrum/Version.scala")

generateVersionFileTask <<= generateVersionFile

(compile in Compile) <<= (compile in Compile) dependsOn (generateVersionFile)

def generateVersionFile = Def.task {
  val versions = version.value.split('.')
  val major    = versions(0).toInt
  val minor    = versions(1).toInt
  val patch    = versions(2).split('-')(0).toInt
  val ma_mi_pa = s"$major.$minor.$patch"
  val base     = (baseDirectory in Compile).value

  // Do not overwrite version file if its content doesn't change
  val file    = base / "src/xitrum/Version.scala"
  val content = s"""// Autogenerated by build.sbt. Do not modify this file directly.
package xitrum
class Version {
  val major = $major
  val minor = $minor
  val patch = $patch
  /** major.minor.patch: $ma_mi_pa */
  override def toString = "$ma_mi_pa"
}
"""
  if (!file.exists) {
    IO.write(file, content)
  } else {
    val oldContent = IO.read(file)
    if (content != oldContent) IO.write(file, content)
  }
}

lazy val xitrumSettings = Seq(
  libraryDependencies ++= Seq(
    // Projects using Xitrum must provide a concrete implementation of SLF4J (Logback etc.)
    "org.slf4s" %% "slf4s-api" % "1.7.12",
    // Netty is the core of Xitrum's HTTP(S) feature
    "io.netty" % "netty-all" % "4.1.0.CR4",
    // https://github.com/netty/netty/wiki/Forked-Tomcat-Native
    // https://groups.google.com/forum/#!topic/netty/oRATC6Tl0A4
    // Include all classifiers for convenience
    "io.netty" % "netty-tcnative" % "1.1.33.Fork15" classifier "linux-x86_64",
    "io.netty" % "netty-tcnative" % "1.1.33.Fork15" classifier "osx-x86_64",
    "io.netty" % "netty-tcnative" % "1.1.33.Fork15" classifier "windows-x86_64",
    // https://github.com/netty/netty/wiki/Native-transports
    // Only works on Linux
    "io.netty" % "netty-transport-native-epoll" % "4.1.0.CR4" classifier "linux-x86_64",
    // Javassist boosts Netty 4 speed
    "org.javassist" % "javassist" % "3.20.0-GA",
    // Redirect Akka log to SLF4J
    "com.typesafe.akka" %% "akka-actor"           % "2.4.1",
    "com.typesafe.akka" %% "akka-cluster"         % "2.4.1",
    "com.typesafe.akka" %% "akka-cluster-metrics" % "2.4.1",
    "com.typesafe.akka" %% "akka-contrib"         % "2.4.1",
    "com.typesafe.akka" %% "akka-slf4j"           % "2.4.1",
    // For clustering SockJS with Akka
    "tv.cntt" %% "glokka" % "2.4",
    // For file watch
    // (akka-agent is added here, should ensure same Akka version as above)
    "com.beachape.filemanagement" %% "schwatcher" % "0.2.0",
    // For scanning routes
    "tv.cntt" %% "sclasner" % "1.7.0",
    // For binary (de)serializing
    "com.twitter" %% "chill" % "0.7.2",
    // For JSON (de)serializing
    //"org.json4s" %% "json4s-jackson" % "3.3.0"
    // For i18n
    "tv.cntt" %% "scaposer" % "1.7",
    // For jsEscape
    "org.apache.commons" % "commons-lang3" % "3.4",
    // For compiling CoffeeScript to JavaScript
    "tv.cntt" % "rhinocoffeescript" % "1.9.3",
    // For metrics
    "nl.grons" %% "metrics-scala" % "3.5.2_a2.3",
    // For metrics
    "io.dropwizard.metrics" % "metrics-json" % "3.1.2",
    // For test --------------------------------------------------------------------
    "org.scalatest" %% "scalatest" % "2.2.5" % "test",
    "com.m3" %% "curly-scala" % "0.5.+" % "test",
    // An implementation of SLF4J is needed for log in tests to be output
    "ch.qos.logback" % "logback-classic" % "1.1.3" % "test"
  ),
  // JSON4S uses scalap 2.10.0/2.11.0, which in turn uses scala-compiler 2.10.0/2.11.0, which in
  // turn uses scala-reflect 2.10.0/2.11.0. We need to force "scalaVersion" above, because
  // Scala annotations (used by routes and Swagger) compiled by a newer version
  // can't be read by an older version.
  //
  // Also, we must release a new version of Xitrum every time a new version of
  // Scala is released.
  libraryDependencies <+= scalaVersion { sv => "org.scala-lang" % "scalap" % sv },
  // jquery-validation declares dependency on jquery as "[1.9.1,)"
  // and SBT wrongly picks up the latest version like 3.0.0-alpha1,
  // so we force the version of jquery back to above
  // For "sbt console"
  unmanagedClasspath in Compile <+= (baseDirectory) map { bd => Attributed.blank(bd / "src/test/resources") },
  // For "sbt run/test"
  unmanagedClasspath in Runtime <+= (baseDirectory) map { bd => Attributed.blank(bd / "src/test/resources") }
)

lazy val migrate = inputKey[Unit]("Run migrations")
lazy val deploy = inputKey[Unit]("Run deployment tasks")


lazy val api = (project in (file(".")))
  .enablePlugins(BuildInfoPlugin)
  .settings(xitrumSettings ++ baseBuildSettings ++ scalateSettings ++ templateSettings ++ Seq(
    unmanagedSourceDirectories in Compile += baseDirectory.value / "src",
    mainClass in (Compile, run) := Some("starman.api.Boot"),
    migrate := Def.inputTaskDyn {
      val args: Seq[String] = spaceDelimited("<arg>").parsed
      (runMain in Compile).toTask(s" starman.data.Migrate ${args.mkString(" ")}")
    }.evaluated,
    deploy := Def.inputTaskDyn {
      val args: Seq[String] = spaceDelimited("<arg>").parsed
      (runMain in Compile).toTask(s" starman.common.Deploy ${args.mkString(" ")}")
    }.evaluated,
    ScalateKeys.scalateTemplateConfig in Compile := Seq(TemplateConfig(
      baseDirectory.value / "templates",
      Seq(),
      Seq(Binding("helper", "xitrum.Action", true))
    )),
    libraryDependencies ++= Seq(
      //"tv.cntt" %% "xitrum" % "3.25.+",
      "org.scalatra.scalate" %% "scalate-core" % "1.7.1",
      "org.scalatra.scalate" %% "scalamd" % "1.6.1",
      "ch.qos.logback" % "logback-classic" % "1.1.3",
      "org.codehaus.janino" % "janino" % "2.7.8",
      "com.roundeights" %% "hasher" % "1.0.0",
      "org.scala-lang" % "scala-reflect" % scalaVersion.value,
      "com.typesafe" % "config" % "1.3.0",
      "log4j" % "log4j" % "1.2.14",
      "com.restfb" % "restfb" % "1.14.0",
      "net.ruippeixotog" %% "scala-scraper" % "0.1.1",
      "com.github.seratch" %% "awscala" % "0.5.+",
      "com.github.dzsessona" %% "scamandrill" % "1.1.0",
      "org.http4s" % "http4s-client_2.11" % "0.11.1",
      "org.http4s" % "http4s-blaze-client_2.11" % "0.11.1",
      "org.squeryl" % "squeryl_2.11" % "0.9.6-RC4",
      "com.jolbox" % "bonecp" % "0.8.0.RELEASE",
      "com.imageworks.scala-migrations" %% "scala-migrations" % "1.1.1",
      "com.github.cb372" %% "scalacache-memcached" % "0.7.4",
      "com.github.cb372" %% "scalacache-core" % "0.7.4",
      "postgresql" % "postgresql" % "9.1-901.jdbc4",
      "com.mindscapehq" % "raygun4java" % "2.0.0",
      "com.mindscapehq" % "core" % "2.0.0",
      "net.sf.uadetector" % "uadetector-core" % "0.9.22",
      "net.sf.uadetector" % "uadetector-resources" % "2014.10",
      "com.vividsolutions" % "jts" % "1.13",
      "org.opentripplanner" % "otp" % "0.13.0",
      "com.chuusai" %% "shapeless" % "2.3.0",
      "org.scalatest" % "scalatest_2.11" % "3.0.0-M14" % "test",
      "org.scalamock" %% "scalamock-scalatest-support" % "3.2" % "test"
    ),
    //parallelExecution in Test := false,
    testOptions in Test += Tests.Setup( () => {
    }),
    testOptions in Test += Tests.Cleanup( () => {
      println("cleanup")
    })
  )
).dependsOn(macros, migrations).aggregate(macros, migrations)

lazy val migrations = (project in (file("migrations")))
  .settings(commonSettings ++ Seq(
    name := "migrations",
    unmanagedSourceDirectories in Compile += baseDirectory.value,
    libraryDependencies ++= Seq(
      "com.imageworks.scala-migrations" %% "scala-migrations" % "1.1.1"
    )
  )
)

/* this is needed solely for the Enum-like StatusCodes used by the API */
lazy val macros  = (project in file("macros"))
  .settings(
    commonSettings ++ Seq(
      name := "macros",
      unmanagedSourceDirectories in Compile += baseDirectory.value,
      libraryDependencies <+= scalaVersion("org.scala-lang" % "scala-compiler" % _)
    )
  )
